//Here we will go over proof of work. Something that is used to
 //prove the legitamcy of a block
//proof of work is generated by the process of mining and has a certain
 //amount of 0s in front of it
//this requires a lot of computing power
//With Bitcoin the aim is to create one new block every minute

const SHA256 = require('crypto-js/sha256');

class Block{
	constructor(index, timestamp, data, previousHash = ''){
		this.index = index;
		this.timestamp = timestamp;
		this.data = data;
		this.previousHash = previousHash;
		this.hash = this.calculateHash();
		//a nonce is a random number that has nothing to do with our block but can be changed
		 //to something random
		this.nonce = 0;
	}

	//we now need to take this nonce into account
	calculateHash(){
		return SHA256(this.index + this.previousHash + this.timestamp
				+ JSON.stringify(this.data) + this.nonce).toString();
	}

	mineBlock(difficulty){
		//make the hash of the block begin with a 
			//certain amount of 0s
		//make an array which is the same length of difficulty
	  while(this.hash.substring(0, difficulty) !== Array(difficulty + 1).join("0")){
	  	//increment this nonce as long as our hash does not start with 0s
	  	this.nonce++;
	  	this.hash = this.calculateHash();
   }
	//we have an issue here being that the hash of 
	   //our block will not change
	 //if we dont change the contents of our block. 
	   //This is now an endless loop.
	 //we will add this by adding a nonce up top.
	console.log("Block mined: " + this.hash);
   }
 }

class Blockchain {
	//set a difficulty
	constructor(){
		this.chain = [this.createGenesisBlock()];
		this.difficulty = 4;
	}

	createGenesisBlock(){
		return new Block(0, "01/01/2017", "Genesis Block", "0");
	}

	getLatestBlock(){
		return this.chain[this.chain.length - 1];
	}

	addBlock(newBlock){
		newBlock.previousHash = this.getLatestBlock().hash;
		// newBlock.hash = newBlock.calculateHash();
		//remove this line and now define:
		newBlock.mineBlock(this.difficulty);
		//and pass the difficulty. 
			//Pass the difficulty to the blockchain
		this.chain.push(newBlock);
	}

	 isChainValid(){
	 	for(let i = 1; i < this.chain.length; i++){
	 		const currentBlock = this.chain[i];
	 		const previousBlock = this.chain[i - 1];

	 		if (currentBlock.hash !== currentBlock.calculateHash()){
	 			return false;
	 		}

	 		
	 		if(currentBlock.previousHash !== previousBlock.hash){
	 			return false;
	 		}
	 	}
	 	return true;
	 }
 }

let danCoin = new Blockchain();
//console log out the mining of the blocks to show proof of work
//hashes of our blocks should start with 
	//2 0s because we set the difficulty to 2
//the time it takes to mine our blocks will 
	//increase depending on the difficulty
console.log("Mining block 1...");
danCoin.addBlock(new Block(1, "10/07/2017", {amount: 4}));
console.log("Mining block 2...");
danCoin.addBlock(new Block(2, "12/07/2017", {amount: 10}));



